var resumeList = []
var typesList = []

function initResume(usingTypes, typesFolderName) {
    var groups = app.activeDocument.layerSets;

    for (var groupIterator = 0; groupIterator < groups.length; ++groupIterator) {
        var group = groups[groupIterator];

        if (usingTypes && group.name.toLowerCase() === typesFolderName) {
            for (var typesIterator = 0; typesIterator < group.layers.length; ++typesIterator) {
                var layerType = group.layers[typesIterator];

                var type = {
                    name: cleanName(layerType.name),
                    timesSeen: 0
                }
                typesList.push(type);
            }

        } else {
            var resume = {
                category: group.name,
                traits: []
            }

            for (var layerIterator = 0; layerIterator < group.layers.length; ++layerIterator) {
                var layer = group.layers[layerIterator];
                var trait = {
                    trait: cleanName(layer.name),
                    timesSeen: 0
                }

                resume.traits.push(trait);
            }

            resumeList.push(resume);
        }
    }
}

function addCategoryAndTrait(category, trait) {
    for (var i = 0; i < resumeList.length; ++i) {
        var resume = resumeList[i];

        if (resume.category === category) {

            for (var k = 0; k < resume.traits.length; ++k) {
                if (resume.traits[k].trait === trait) {
                    ++resumeList[i].traits[k].timesSeen;
                    return;
                }
            }
        }
    }
}

function addTypeInResume(type) {
    for (var i = 0; i < typesList.length; ++i) {
        var typeSelect = typesList[i];

        if (typeSelect.name === type) {
            ++typesList[i].timesSeen;
            return;
        }
    }
}

function writeResumeFile(nftAmount, collecName, collecDescription, usingTypes, typesMetadataVisible, isPng8) {
    var endDate = new Date();
    var buildFolder = getBuildFolderName();
    var resumeFile = new File(toFolder(buildFolder) + "/resume-generation.txt");
    var data = "/**\n" +
        "* File generated by the script created by Funix.\n" +
        "* Used to see how many times the layers have been selected for your collection.\n" +
        "* Twitter: @FunixGaming\n" +
        "* E-Mail: contact@funixgaming.fr\n" +
        "* \n" +
        "* NFT amount: " + nftAmount + "\n" +
        "* NFT collection name: " + collecName + "\n" +
        "* NFT collection description: " + collecDescription + "\n" +
        "* Using types system: " + usingTypes + "\n" +
        "* Types visible in the metadata: " + typesMetadataVisible + "\n" +
        "* PNG-8 export: " + isPng8 + "\n" +
        "* Generated started at " + date.getDate() + "/" + (date.getMonth() + 1) + "/" + date.getFullYear() + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds() + "\n" +
        "* Generated ended at " + endDate.getDate() + "/" + (endDate.getMonth() + 1) + "/" + endDate.getFullYear() + " " + endDate.getHours() + ":" + endDate.getMinutes() + ":" + endDate.getSeconds() + "\n" +
        "**/\n\n";

    if (usingTypes) {
        data += "- Types used:\n";
        for (var typesIterator = 0; typesIterator < typesList.length; ++ typesIterator) {
            var typeSelec = typesList[typesIterator];

            data += typeSelec.name + " (" + getPourcentage(nftAmount, typeSelec.timesSeen) + "%, " + typeSelec.timesSeen + " times used)\n";
        }
        data += "\n";
    }

    for (var i = 0; i < resumeList.length; ++i) {
        var resume = resumeList[i];

        data += "- " + resume.category + "\n";
        for (var k = 0; k < resume.traits.length; ++k) {
            var trait = resume.traits[k];

            data += trait.trait + " (" + getPourcentage(nftAmount, trait.timesSeen) + "%, " + trait.timesSeen + " times used)\n"
        }
        data += "\n";
    }

    resumeFile.encoding = "UTF8";
    resumeFile.open("w");
    resumeFile.write(data);
    resumeFile.close();
}

function getPourcentage(maxItems, nbrItems) {
    return (100 * (nbrItems / maxItems)).toString();
}
